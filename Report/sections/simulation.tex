\documentclass[../main.tex]{subfiles}
 
\begin{document}
When thinking of simulating a Quantum Computer, there are a number of possible ways to implement it, depending on what you want from your simulator.
Regardless of what method, it will always get exponentially slower as you add more Qubits to simulate, as the number of amplitudes you need to store is \(2^n\). 
To get the most accurate simulation, you need to also simulate 'Decoherence', which is where the system will loose information due to measurements by the outside environment, although the simulator detailed here is called an 'Ideal' Simulator, as it doesn't also simulate Decoherence.
In this project, the simulator will be built upon vector-matrix opperations.

\subsection{Quantum Register}
When you start the simulator, you have to have a new Quantum Register. When a new Quantum Register is created, it creates a new \(2^n\) dimensional vector of zero, and then it sets the first 0 to 1. This is the same as representing an n Qubit state, and setting all n Qubits to the state \(\lvert0\rangle\). Remember:

$$
\lvert q_1 q_2...q_n \rangle = \lvert q1 \rangle \otimes \lvert q2 \rangle \otimes ... \otimes \lvert q_n \rangle
$$

So therefore, the vector that must be stored for 4 Qubits in the state of 0000 is:

$$
\lvert0000\rangle = \lvert0\rangle \otimes \lvert0\rangle \otimes \lvert0\rangle \otimes \lvert0\rangle = \left( \begin{matrix} 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{matrix} \right)
$$

When a new Quantum Register Is Defined, it stores the vector, so that gates can be applied to it.

\subsection{Matrix Generation}
If you look at the gates defined in the Previous Section, 'Quantum Logic Gates' (For Example, Equation (3)), they are all either \(2\times2\) or \(4\times4\) Matrices, which means that they can only be applied to either a 2 or 4 dimensional vector. This is a problem for our computational model, as we create a large \(2^n\) Dimensional Vector.

\subsubsection{Expanding Single Qubit Gates}
Essentially, what we are trying to do it take a 2x2 matrix, and scale it up, so that it a \(2^n\) x \(2^n\) matrix. Whats important, is that the new matrix must only affect the Qubit its targeting. For example, if I had a 4 Qubit Register, and I wanted to apply an \(X\) Gate to the 3rd Qubit, The equation for that new matrix is \(X_{3,4} = Id \otimes Id \otimes X \otimes Id \), with \(Id\) Being a 2x2 Identity Matrix. \\
To generalise this further, to create the gate \(G_{m,n}\) (With \(n\) being the number of Qubits in the register, \(m\) being the number of the Qubit the gate will act on, and \(G\) Being the 2x2 gate that will be applied to that Qubit), 
you can use the equation:

\begin{equation} \label{eq:single-gate-gen}
	G_{m,n} = \underset{i=1}{\overset{n}{\otimes}}
	\begin{cases}
    	G & \text{if} \quad i = m \\
    	Id & \text{if} \quad i \neq m
	\end{cases}
\end{equation}

(Note: \(\underset{i=1}{\overset{n}{\otimes}}\) is like \(\underset{i=1}{\overset{n}{\sum}}\), but using the kronecker product, instead of the sum.)

\subsubsection{Expanding Multi-Qubit Gates}
Focusing on Controlled Gates, there are a number of ways to expand / scale up Multi-Qubit gates, but most of them are quite long winded (See the appendix for a general expansion method),
but the way that the CNOT / Controlled X Gate is implemented in the simulator, is using a Input-Output like structure to generate a new matrix. \\
There is no equation for this gate (Again, see the appendices for a full, generalised mathematical solution), but the generation method for this simulator can be shown using the source code. \\ \\ 

\subsection{Applying Gates}
Once there is a state vector and a full, unitary matrix to apply to it,
you can then apply the gate by multiplying the state or amplitude vector (\(\psi\)), and the matrix of the gate \(G\) \\
\begin{equation}
	\lvert\psi\rangle \cdot G
\end{equation}

For example, to apply a Pauli-X Gate (Not Gate) to the second Qubit of a 2-Qubit Register, it would look as shown (Keep in mind the previous Gate Matrix Generation Equations):

$$
	Id = \left [\begin{matrix}
		1 && 0 \\
		0 && 1
	\end{matrix}\right]
$$
	\\
$$
	X = \left [\begin{matrix}
		0 && 1 \\
		1 && 0
	\end{matrix}\right]
$$
	\\
$$	
	X_{2,2} = Id \otimes X = \left [\begin{matrix}
		0 && 1 && 0 && 0 \\
		1 && 0 && 0 && 0 \\
		0 && 0 && 0 && 1 \\
		0 && 0 && 1 && 0
	\end{matrix}\right]
$$	

$$
\lvert00\rangle \cdot X_{2,2} = \left[\begin{matrix}
		0 && 1 && 0 && 0 \\
		1 && 0 && 0 && 0 \\
		0 && 0 && 0 && 1 \\
		0 && 0 && 1 && 0
\end{matrix}\right] \cdot \left[\begin{matrix}
	1 \\
	0 \\
	0 \\
	0 \\
\end{matrix}\right] = \left[\begin{matrix}
	0 \\
	1 \\
	0 \\
	0 \\
\end{matrix}\right] = \lvert01\rangle
$$
		
\subsection{Writing The Simulator}
With the various components now defined, the actual implementation of the simulator is quite easy.
I chose to use the language Python for its great math library, Numpy. It had all of the features that I needed, and the speed was comparable to that of Matlab, Octave etc.
It also had the advantage of being quite a clear and simple language, and it is used by many more people then other, math focused languages

\subsubsection{Writing the register}
For the register / amplitude vector, it is stored in a numpy vector.
First of all, the number of amplitudes needed is looked at, and from that, an empty vector (filled with zeros) is created. Then the first zero in the vector is set to one, so that the state is in 
$$
\lvert 000...0 \rangle
$$

This is done each time a new register is made, so it is in the \emph{init} function of the \emph{QuantumRegister} class.

\lstinputlisting[language=Python,firstline=109,lastline=121]{../Code/Simulator/QuSim.py}

\subsubsection{Writing the Gate Generator}
All of the single qubit gates are hardcoded into the simulator using a Dictionary data structure. For example, the Pauli-X gate is:
\lstinputlisting[language=Python,firstline=17,lastline=21]{../Code/Simulator/QuSim.py}
Although some of the gates are coded in using functions from Numpy, for example the identity gate:
\lstinputlisting[language=Python,firstline=37,lastline=38]{../Code/Simulator/QuSim.py}
The 'Dagger' Gates:
\lstinputlisting[language=Python,firstline=39,lastline=56]{../Code/Simulator/QuSim.py}

To generate the gates, the formula \ref{eq:single-gate-gen}
is used.

The gate generation function takes four inputs:
\begin{itemize}
	\item \emph{gate}: The gate to be applied (i.e. X)
	\item \emph{numQubits}: The number of qubits in the register the gate will be applied to.
	\item \emph{qubit1}: The main qubit. In the case of a single qubit gate, it will be the qubit the gate is to be applied on. In the case of a Controled gate (CNOT), it is the target
	\item \emph{qubit2}: In the case that its a controlled gate being applied (CNOT), then this would be the target qubit. It has a default value of 1, and doesn't need to be used if its not a CNOT
\end{itemize}

The way the function works is that it builds up a list of operations, and then uses the \emph{reduce()} function to run the calculation. This is the same as formula ~\ref{eq:single-gate-gen}, where builds up the order and then uses the kronecker product on them. The function is:


\begin{lstlisting}[language=Python]
def generateGate(gate, numQubits, qubit1, qubit2=1):
    else:
        # Put these here for handyness
        identity = gates.singleQubitGates['Id']
        mainGate = gates.singleQubitGates[gate]

        gateOrder = []

        for i in range(1, numQubits + 1):
            if (i == qubit1):
                gateOrder.append(mainGate)
            else:
                gateOrder.append(identity)

        return reduce(np.kron, gateOrder)
\end{lstlisting}

So that code works if you want to generate a gate that only acts on one qubit, but we have to do something else if we want to use a CNOT gate. The way this function works is based on the "Formula" in the Appendix, and the finished Gate Generation function is this:

\lstinputlisting[language=Python,firstline=63,lastline=106]{../Code/Simulator/QuSim.py}

\end{document}


